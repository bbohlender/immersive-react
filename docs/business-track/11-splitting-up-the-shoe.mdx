---
title: Splitting up the Shoe
description:
nav: 11
---

> [!NOTE]
> If you prefer programming in your local development environment, clone `https://github.com/bbohlender/ir-business-track-baseline.git` or continue developing in your local existing code base.


We begin our Shoe Configurator loading the shoe model and splitting it into parts using gltf.pmnd.rs, so we can declaratively control them individually. Furthermore, we are changing our app into an Augmented Reality app.

<Sandpack codeViewer
  template="react-ts"
  customSetup={{
    dependencies: {
      'three': '~0.168.0',
      '@react-three/fiber': 'latest',
      '@react-three/drei': 'latest',
      '@react-three/xr': 'latest',
    },
  }}
  files={{
    '/App.tsx': `import { Canvas, useFrame } from "@react-three/fiber";
import { useState, useRef } from "react";
import { useGLTF, Environment } from "@react-three/drei";
import { createXRStore, XR } from "@react-three/xr";
import { Mesh } from "three";

const store = createXRStore({ emulate: { inject: true }, hand: {
    grabPointer: false,
    touchPointer: false,
    rayPointer: { minDistance: 0 },
  },
  controller: { grabPointer: false, rayPointer: { minDistance: 0 } }, });

export default function App() {
  return (<>
    <button style={{ position: "absolute", zIndex: "1" }} onClick={() => store.enterAR()}>
        Enter AR
    </button>
    <Canvas style={{ position: "absolute", inset: "0", touchAction: "none" }}>
      <XR store={store}>
        <Environment preset="warehouse" />
        <MyComponent />
        <MyModel />
      </XR>
    </Canvas>
    </>
  )
}

function MyModel() {
    const { scene } = useGLTF("https://www.immersive-react.com/shoe.glb")
    return <primitive object={scene} />
}

function MyComponent() {
    const [red, setRed] = useState(true)
    const ref = useRef<Mesh>(null)
    useFrame(() => ref.current?.rotateY(0.01)) 
    return <mesh ref={ref} onClick={() => setRed(!red)} position={[ 0, 0, 0 ]}>
        <boxGeometry/>
        <meshBasicMaterial color={red ? "red" : "blue"} />
    </mesh>
}

`, 'model.tsx': ``}}/>

Let's first, change our enter button to enter into Augmented Reality mode instead of Virtual Reality mode. To do this we modify its content to `Enter AR` and change the `onClick` handler to `store.enterAR()`.

```tsx
onClick={() => store.enterVR()}
```

Next, we remove the `MyComponent` and `MyModel` components and their usage inside of the `Canvas`. Download the <a download href="https://www.immersive-react.com/shoe.glb">shoe.glb</a> model and drag it into [gltf.pmnd.rs](gltf.pmnd.rs). Once the model is uploaded, switch on the types option in the right-hand panel. Copy the output generated by gltf.pmnd.rs, paste it into the `model.tsx` file, and replace the `shoe.glb` URL with `https://www.immersive-react.com/shoe.glb` both in `useGLTF` and in `useGLTF.preload` at the end. Also, remove the `castShadow` and `receiveShadow` properties from the model to simplify the rendering setup.

Now add the `Model` compnent inside the `XR` tag in `App.tsx` and wrap it in a group position the group in fron the user at `{[0, 1.1, -0.3]}`, and set its scale `0.2`. With this setup, we have a declaratively delcared shoe rendered in our 3D app.

```tsx
<Canvas >
  <XR store={store}>
    <Environment preset="warehouse" />
    <group position={[0, 1.1, -0.3]} scale={0.2}>
      <Model />
    </group>
  </XR>
</Canvas>
```

Next, we create the `InteractableMesh` component to make each part of the shoe individually interactable. The component returns a mesh with geometry and material attributes provided through the InteractableMesh properties. Additionally, we add a `useState` hook for the boolean `red` state. We add an `onClick` handler to toggle the `red` state.

```tsx
function InteractableMesh({ geometry, material }: { geometry: BufferGeometry, material: Material }) {
  const [red, setRed] = useState(false)
  return <mesh onClick={() => setRed(!red)} geometry={geometry} material={material} material-color={red ? "red" : "blue"} />
}
```

Lastly, we replace all mesh tags inside the `Model` component with `InteractableMesh` tags while keeping the geometry and material properties.

```tsx
<group {...props} dispose={null}>
  <InteractableMesh geometry={nodes.shoe.geometry} material={materials.laces} />
  {/* same for all other meshes in the Model component*/}
</group>
```

